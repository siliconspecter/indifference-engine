<html>

<head>
  <meta charset="utf-8">
  <title>Indifference Engine</title>

  <!-- INSERT-FAVICONS-GENERATED-HTML-HERE -->

  <style>
    html {
      font-family: Helvetica, Arial, sans-serif;
      background: black;
      color: white;
      font-size: 5vmin;
    }

    * {
      margin: 0;
      padding: 0;
      user-select: none;
      cursor: default;
    }

    div {
      width: calc(100vw - 3rem);
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    p {
      display: inline-block;
      text-align: left;
    }

    canvas {
      position: fixed;
      left: 50%;
      top: 50%;
      cursor: none;
      visibility: hidden;
      image-rendering: pixelated;
      background: red;
    }
  </style>
</head>

<body>
  <div>
    <p>Starting up...</p>
  </div>
  <canvas></canvas>
  <script defer>
    const messageElement = document.getElementsByTagName('p')[0]

    const setMessage = (to) => {
      messageElement.textContent = to
      messageElement.style.visibility = 'visible'
    }

    const loadGame = async () => {
      setMessage('Loading game...')

      try {
        const module = await WebAssembly.instantiateStreaming(fetch('INSERT-WASM-MODULE-PATH-HERE' + '?' + Date.now()))

        setMessage('Starting game...')

        const getOptionalExport = (name) => {
          if (Object.prototype.hasOwnProperty.call(module.instance.exports, name)) {
            return module.instance.exports[name]
          } else {
            return null
          }
        }

        const getRequiredExport = (name) => {
          const exported = getOptionalExport(name)
          if (exported === null) {
            throw new Error(`The WASM module lacks a "${name}" export.`)
          } else {
            return exported
          }
        }

        const memory = getRequiredExport('memory')

        if (!(memory instanceof WebAssembly.Memory)) {
          throw new Error("The WASM module's \"memory\" export is not WebAssembly memory.")
        }

        const getOptionalFunction = (name) => {
          const exported = getOptionalExport(name)

          if (exported === null || typeof exported === 'function') {
            return exported
          } else {
            throw new Error(`The WASM module's "${name}" export is not a function.`)
          }
        }

        const getRequiredFunction = (name) => {
          const exported = getOptionalFunction(name)

          if (exported === null) {
            throw new Error(`The WASM module lacks a "${name}" export.`)
          } else {
            return exported
          }
        }

        const getConstant = (functionName) => getRequiredFunction(functionName)()

        const getNumericConstant = (functionName) => {
          const constant = getConstant(functionName)

          if (typeof constant !== 'number') {
            throw new Error(`The WASM module's "${name}" export did not return a number.`)
          } else if (!Number.isFinite(constant)) {
            throw new Error(`The WASM module's "${name}" export returned a number which is not finite.`)
          } else {
            return constant
          }
        }

        const getIntegerConstant = (functionName) => {
          const number = getNumericConstant(functionName)

          if (Number.isSafeInteger(number)) {
            return number
          } else {
            throw new Error(`The WASM module's "${name}" export returned a number which is not an integer.`)
          }
        }

        const getUnsignedS32Constant = (functionName) => {
          const integer = getIntegerConstant(functionName)

          if (integer < -2147483648) {
            throw new Error(`The WASM module's "${name}" export returned a number which is lesser than that of a valid unsigned s32.`)
          } else if (integer > 2147483647) {
            throw new Error(`The WASM module's "${name}" export returned a number which is greater than that of a valid unsigned s32.`)
          } else {
            return integer
          }
        }

        const getMemoryPointer = (functionName, constructor, length) => {
          const integer = getIntegerConstant(functionName)

          if (integer < 0) {
            throw new Error(`The WASM module's "${name}" export returned a pointer which overlaps the start of memory.`)
          } else if (integer + length * constructor.BYTES_PER_ELEMENT > memory.buffer.byteLength) {
            throw new Error(`The WASM module's "${name}" export returned a pointer which overlaps the end of memory.`)
          } else if (integer % constructor.BYTES_PER_ELEMENT !== 0) {
            throw new Error(`The WASM module's "${name}" export returned a pointer which is not aligned correctly (must be a multiple of ${constructor.BYTES_PER_ELEMENT}).`)
          } else {
            return new constructor(memory.buffer, integer, length)
          }
        }

        const stateBuffers = getUnsignedS32Constant('buffer_count')
        const stateBufferLocations = getMemoryPointer('buffer_pointers', Uint32Array, stateBuffers)
        const stateBufferSizes = getMemoryPointer('buffer_sizes', Int32Array, stateBuffers)
        const stateBufferIdentifiers = getMemoryPointer('buffer_identifiers', Int32Array, stateBuffers)
        let tick = getOptionalFunction('tick')
        let audio = getOptionalFunction('audio')
        const video = getOptionalFunction('video')

        const state = new Map()

        let ticksPerSecond = null
        let audioSamples = null
        let maximumVideoRows = null
        let safeAreaRows = null
        let safeAreaColumns = null
        let videoColors = null
        let pointerState = null
        let pointerRow = null
        let pointerColumn = null
        let persist = null
        let tickProgress = null
        let videoRows = null
        let videoColumns = null
        let listenerNormal = null
        let controllerStates = null
        let controllerYAxes = null
        let controllerXAxes = null
        let error = null

        const localStorageText = localStorage.getItem('INSERT-LOCAL-STORAGE-KEY-HERE')

        const localStorageJson = localStorageText === null ? null : JSON.parse(localStorageText)

        for (let i = 0; i < stateBuffers; i++) {
          const identifier = stateBufferIdentifiers[i]

          if (state.has(identifier)) {
            throw new Error(`Buffer identifier "${identifier}" appears more than once.`)
          } else {
            const size = stateBufferSizes[i]
            const location = stateBufferLocations[i]

            if (size === 0) {
              throw new Error(`Buffer "${identifier}" has a size of 0.`)
            } else if (location + size > memory.buffer.byteLength) {
              throw new Error(`Buffer "${identifier}" overlaps the end of memory.`)
            } else if (identifier >= 0 && identifier <= 1073741823) {
              const state = new Uint8Array(memory.buffer, location, size)

              state.set(identifier, state)

              if (localStorageJson !== null && Object.prototype.hasOwnProperty.call(localStorageJson, identifier)) {
                const persisted = atob(localStorageJson[identifier])

                if (persisted.length === state.length) {
                  for (let index = 0; index < persisted.length; index++) {
                    state[index] = persisted.codePointAt(index)
                  }
                }
              }
            } else if (identifier >= -1073741824 && identifier <= -1) {
              throw new Error(`Buffer "${identifier}" is required by the WASM module but is not supported by this hosting runtime.`)
            } else {
              switch (identifier) {
                case 1073741824:
                  if (size === 4) {
                    ticksPerSecond = new Int32Array(memory.buffer, location, 1)[0]

                    if (ticksPerSecond < 1) {
                      throw new Error(`Ticks per second incorrect; expected at least 1, actual ${ticksPerSecond}.`)
                    }
                  } else {
                    throw new Error(`Ticks per second size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741825:
                  if (size % 4 === 0) {
                    audioSamples = new Float32Array(memory.buffer, location, size / 4)
                  } else {
                    throw new Error(`Audio samples size incorrect; expected multiple of 4, actual ${size}.`)
                  }
                  break

                case 1073741826:
                  if (size === 4) {
                    maximumVideoRows = new Int32Array(memory.buffer, location, 1)[0]

                    if (maximumVideoRows < 1) {
                      throw new Error(`Maximum video rows incorrect; expected at least 1, actual ${maximumVideoRows}.`)
                    }
                  } else {
                    throw new Error(`Maximum video rows size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741827:
                  if (size === 4) {
                    safeAreaRows = new Int32Array(memory.buffer, location, 1)[0]

                    if (safeAreaRows < 1) {
                      throw new Error(`Safe area rows incorrect; expected at least 1, actual ${safeAreaRows}.`)
                    }
                  } else {
                    throw new Error(`Safe area rows size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741828:
                  if (size === 4) {
                    safeAreaColumns = new Int32Array(memory.buffer, location, 1)[0]

                    if (safeAreaColumns < 1) {
                      throw new Error(`Safe area columns incorrect; expected at least 1, actual ${safeAreaRows}.`)
                    }
                  } else {
                    throw new Error(`Safe area columns size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741829:
                  if (size % 4) {
                    throw new Error(`Video colors size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    videoColors = new Uint8ClampedArray(memory.buffer, location, size)
                  }
                  break

                case 1073741830:
                  if (size === 4) {
                    pointerState = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Pointer state size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741831:
                  if (size === 4) {
                    pointerRow = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Pointer row size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741832:
                  if (size === 4) {
                    pointerColumn = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Pointer column size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741833:
                  if (size === 4) {
                    persist = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Persist size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741834:
                  if (size === 4) {
                    tickProgress = new Float32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Tick progress size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741835:
                  if (size === 4) {
                    videoRows = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Video rows size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741836:
                  if (size === 4) {
                    videoColumns = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Video columns size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741838:
                  if (size === 12) {
                    listenerNormal = new Float32Array(memory.buffer, location, 3)
                  } else {
                    throw new Error(`Listener normal size incorrect; expected 12, actual ${size}.`)
                  }
                  break

                case 1073741839:
                  if (size % 4) {
                    throw new Error(`Controller states size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    controllerStates = new Int32Array(memory.buffer, location, size / 4)
                  }
                  break

                case 1073741840:
                  if (size % 4) {
                    throw new Error(`Controller Y axes size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    controllerYAxes = new Float32Array(memory.buffer, location, size / 4)
                  }
                  break

                case 1073741841:
                  if (size % 4) {
                    throw new Error(`Controller X axes size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    controllerXAxes = new Float32Array(memory.buffer, location, size / 4)
                  }
                  break

                case 1073741842:
                  if (size === 4) {
                    error = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Error size incorrect; expected 4, actual ${size}.`)
                  }
                  break
              }
            }
          }
        }

        if (videoColors !== null && maximumVideoRows === null) {
          videoColors = null
          console.warn('Unable to use video colors without maximum video rows.')
        }

        if (maximumVideoRows !== null && videoColors === null) {
          maximumVideoRows = null
          console.warn('Unable to use maximum video rows without a video colors.')
        }

        if (videoColors !== null && videoColors.length % maximumVideoRows) {
          throw new Error('Length of video colors not evenly divisible by the maximum number of video rows.')
        }

        const maximumVideoColumns = videoColors.length / maximumVideoRows

        if (safeAreaRows !== null && videoColors === null) {
          safeAreaRows = null
          console.warn('Unable to use safe area rows without video colors.')
        }

        if (safeAreaRows === null) {
          safeAreaRows = maximumVideoRows
        } else if (safeAreaRows > maximumVideoRows) {
          throw new Error('Safe area rows greater than video rows.')
        }

        if (safeAreaColumns !== null && videoColors === null) {
          safeAreaColumns = null
          console.warn('Unable to use safe area columns without video colors.')
        }

        if (safeAreaColumns === null) {
          safeAreaColumns = maximumVideoColumns
        } else if (safeAreaColumns > maximumVideoColumns) {
          throw new Error('Safe area columns greater than video columns.')
        }

        if (tickProgress !== null && ticksPerSecond === null) {
          tickProgress = null
          console.warn('Unable to use tick progress without ticks per second.')
        }

        if (audioSamples !== null && ticksPerSecond === null) {
          audioSamples = null
          console.warn('Unable to use audio samples without ticks per second.')
        }

        if (videoRows !== null && videoColors === null) {
          videoRows = null
          console.warn('Unable to use video rows without video colors.')
        }

        if (videoColumns !== null && videoColors === null) {
          videoColumns = null
          console.warn('Unable to use video columns without video colors.')
        }

        if (tick !== null && ticksPerSecond === null) {
          tick = null
          console.warn('Unable to use tick without ticks per second.')
        }

        if (tickProgress !== null && tick === null) {
          tickProgress = null
          console.warn('Unable to use tick progress without tick.')
        }

        if (tickProgress !== null && video === null) {
          tickProgress = null
          console.warn('Unable to use tick progress without video.')
        }

        if (audioSamples !== null && audio === null) {
          audioSamples = null
          console.warn('Unable to use audio samples without audio.')
        }

        if (audio !== null && audioSamples === null) {
          audio = null
          console.warn('Unable to use audio without audio samples.')
        }

        if (pointerRow !== null && pointerState === null) {
          pointerRow = null
          console.warn('Unable to use pointer row without pointer state.')
        }

        if (pointerRow !== null && videoColors === null) {
          pointerRow = null
          console.warn('Unable to use pointer row without video colors.')
        }

        if (pointerColumn !== null && pointerState === null) {
          pointerColumn = null
          console.warn('Unable to use pointer column without pointer state.')
        }

        if (pointerColumn !== null && videoColors === null) {
          pointerColumn = null
          console.warn('Unable to use pointer column without video colors.')
        }

        if (listenerNormal !== null && audioSamples === null) {
          listenerNormal = null
          console.warn('Unable to use listener normal without audio samples.')
        }

        if (controllerYAxes !== null && controllerStates === null) {
          controllerYAxes = null
          console.warn('Unable to use controller Y axes without controller states.')
        }

        if (controllerYAxes !== null && controllerYAxes.length !== controllerStates.length) {
          throw new Error(`Inconsistent number of controllers between states (${controllerStates.length}) and Y axes (${controllerYAxes.length}).`)
        }

        if (controllerXAxes !== null && controllerStates === null) {
          controllerXAxes = null
          console.warn('Unable to use controller X axes without controller states.')
        }

        if (controllerXAxes !== null && controllerXAxes.length !== controllerStates.length) {
          throw new Error(`Inconsistent number of controllers between states (${controllerStates.length}) and X axes (${controllerXAxes.length}).`)
        }

        // TODO: video/videoCOlors combine check

        // TODO
        if (videoColors === null) {
          throw new Error('Games without video colors are currently unsupported.')
        }

        // TODO
        if (tick === null) {
          throw new Error('Games without tick are currently unsupported.')
        }

        let previousVideoRows = null
        let previousVideoColumns = null

        let videoColorsImageData = null

        let canvasVisible = false

        const canvasElement = document.getElementsByTagName('canvas')[0]
        // canvasElement.height = videoBufferRows
        // canvasElement.width = videoBufferColumns

        canvasElement.addEventListener('mousemove', (e) => {
          // cursorAvailable = true
          // cursorX = e.layerX
          // cursorY = e.layerY
        })

        canvasElement.addEventListener('mouseout', (e) => {
          // cursorAvailable = false
          // cursorClicking = false
        })

        canvasElement.addEventListener('mousedown', () => {
          // cursorClicking = true
        })

        canvasElement.addEventListener('mouseup', () => {
          // cursorClicking = false
        })

        const canvasContext = canvasElement.getContext('2d')

        if (canvasContext === null) {
          throw new Error('Failed to create a 2D context for the canvas.')
        }

        let previousTimestamp = null

        const nextAnimationFrame = (timestamp) => {
          try {
            const windowRows = window.innerHeight
            const rowScale = windowRows / safeAreaRows
            const windowColumns = window.innerWidth
            const columnScale = windowColumns / safeAreaColumns
            const scale = Math.min(rowScale, columnScale)
            const nextVideoRows = Math.max(1, Math.floor(Math.min(maximumVideoRows, windowRows / scale)))
            const nextVideoColumns = Math.max(1, Math.floor(Math.min(maximumVideoColumns, windowColumns / scale)))

            if (nextVideoRows !== previousVideoRows || nextVideoColumns !== previousVideoColumns) {
              canvasElement.height = nextVideoRows
              canvasElement.width = nextVideoColumns
              canvasElement.style.transform = `translate(-50%, -50%) scale(${scale})`

              console.log(nextVideoColumns, nextVideoRows, videoColors.length)

              videoColorsImageData = new ImageData(videoColors, nextVideoColumns, nextVideoRows)

              previousVideoRows = nextVideoRows
              previousVideoColumns = nextVideoColumns
            }

            // TODO: Update pointer state

            if (previousTimestamp !== null && tickProgress !== null) {
              // TODO: Skip most of this if the audio system is running
              const deltaTicks = Math.min(Math.max(100, 1000 / ticksPerSecond), Math.max(0, timestamp - previousTimestamp)) / (1000 / ticksPerSecond)

              tickProgress[0] += deltaTicks

              while (tickProgress[0] >= 1) {
                tick()
                tickProgress[0]--
              }

              previousTimestamp = timestamp
            }

            // TODO: Execute render callback

            if (!canvasVisible) {
              canvasElement.style.visibility = 'visible'
              canvasVisible = true
            }

            // TODO: Add canvas element and hide message if detached

            requestAnimationFrame(nextAnimationFrame)
          } catch (reason) {
            console.error(reason)

            if (canvasVisible) {
              canvasElement.style.visibility = 'hidden'
            }

            // TODO: Stop audio context

            setMessage('Failed to run the game.  Please ensure reload the page.  Report this problem alongside the name and version of your browser, operating system and device should it persist.')
          }
        }

        requestAnimationFrame(nextAnimationFrame)

        // TODO: create canvas, requestAnimationFrame
        // TODO: tick may end up here
      } catch (reason) {
        console.error(reason)
        setMessage('Failed to load the game.  Please ensure that you have a stable internet connection and reload the page.  Report this problem alongside the name and version of your browser, operating system and device should it persist.')
      }
    }

    if (false && ('serviceWorker' in navigator)) {
      setMessage('Registering service worker...')

      navigator.serviceWorker
        .register('INSERT-SERVICE-WORKER-JS-PATH-HERE')
        .then(() => {
          loadGame()
        })
        .catch(reason => {
          console.error(reason)
          setMessage('Failed to configure a service worker.  Please reload the page.  Report this problem alongside the name and version of your browser, operating system and device should it persist.')
        })
    } else {
      loadGame()
    }
  </script>
</body>

</html>
