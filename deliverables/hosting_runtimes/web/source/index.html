<html>

<head>
  <meta charset="utf-8">
  <title>Indifference Engine</title>

  <!-- INSERT-FAVICONS-GENERATED-HTML-HERE -->

  <style>
    html {
      font-family: Helvetica, Arial, sans-serif;
      background: black;
      color: white;
      font-size: 5vmin;
    }

    * {
      margin: 0;
      padding: 0;
      user-select: none;
      cursor: default;
    }

    div {
      width: calc(100vw - 3rem);
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    p {
      display: inline-block;
      text-align: left;
    }

    canvas {
      position: fixed;
      left: 50%;
      top: 50%;
      cursor: none;
      visibility: hidden;
      image-rendering: pixelated;
    }
  </style>
</head>

<body>
  <div>
    <p>Starting up...</p>
  </div>
  <canvas></canvas>
  <script defer>
    const messageElement = document.getElementsByTagName('p')[0]

    const setMessage = (to) => {
      messageElement.textContent = to
      messageElement.style.visibility = 'visible'
    }

    const loadGame = async () => {
      setMessage('Loading game...')

      try {
        const module = await WebAssembly.instantiateStreaming(fetch('INSERT-WASM-MODULE-PATH-HERE' + '?' + Date.now()))

        setMessage('Starting game...')

        const getOptionalExport = (name) => {
          if (Object.prototype.hasOwnProperty.call(module.instance.exports, name)) {
            return module.instance.exports[name]
          } else {
            return null
          }
        }

        const getRequiredExport = (name) => {
          const exported = getOptionalExport(name)
          if (exported === null) {
            throw new Error(`The WASM module lacks a "${name}" export.`)
          } else {
            return exported
          }
        }

        const memory = getRequiredExport('memory')

        if (!(memory instanceof WebAssembly.Memory)) {
          throw new Error("The WASM module's \"memory\" export is not WebAssembly memory.")
        }

        const getOptionalFunction = (name) => {
          const exported = getOptionalFunction(name)

          if (typeof exported === 'function') {
            return exported
          } else {
            throw new Error(`The WASM module's "${name}" export is not a function.`)
          }
        }

        const getRequiredFunction = (name) => {
          const exported = getOptionalFunction(name)

          if (exported === null) {
            throw new Error(`The WASM module lacks a "${name}" export.`)
          } else {
            return exported
          }
        }

        const getConstant = (functionName) => getRequiredFunction(functionName)()

        const getNumericConstant = (functionName) => {
          const constant = getConstant(functionName)

          if (typeof constant !== 'number') {
            throw new Error(`The WASM module's "${name}" export did not return a number.`)
          } else if (!Number.isFinite(constant)) {
            throw new Error(`The WASM module's "${name}" export returned a number which is not finite.`)
          } else {
            return constant
          }
        }

        const getIntegerConstant = (functionName) => {
          const number = getNumericConstant(functionName)

          if (Number.isSafeInteger(number)) {
            return number
          } else {
            throw new Error(`The WASM module's "${name}" export returned a number which is not an integer.`)
          }
        }

        const getUnsignedS32Constant = (functionName) => {
          const integer = getIntegerConstant(functionName)

          if (integer < -2147483648) {
            throw new Error(`The WASM module's "${name}" export returned a number which is lesser than that of a valid unsigned s32.`)
          } else if (integer > 2147483647) {
            throw new Error(`The WASM module's "${name}" export returned a number which is greater than that of a valid unsigned s32.`)
          } else {
            return integer
          }
        }

        const getMemoryPointer = (functionName, constructor, length) => {
          const integer = getIntegerConstant(functionName)

          if (integer < 0) {
            throw new Error(`The WASM module's "${name}" export returned a pointer which overlaps the start of memory.`)
          } else if (integer + length * constructor.BYTES_PER_ELEMENT > memory.buffer.byteLength) {
            throw new Error(`The WASM module's "${name}" export returned a pointer which overlaps the end of memory.`)
          } else if (integer % constructor.BYTES_PER_ELEMENT !== 0) {
            throw new Error(`The WASM module's "${name}" export returned a pointer which is not aligned correctly (must be a multiple of ${constructor.BYTES_PER_ELEMENT}).`)
          } else {
            return new constructor(memory.buffer, integer, length)
          }
        }

        const stateBuffers = getUnsignedS32Constant('buffer_count')
        const stateBufferLocations = getMemoryPointer('buffer_pointers', Uint32Array, stateBuffers)
        const stateBufferSizes = getMemoryPointer('buffer_sizes', Int32Array, stateBuffers)
        const stateBufferIdentifiers = getMemoryPointer('buffer_identifiers', Int32Array, stateBuffers)
        let tick = getOptionalFunction('tick')
        let audio = getOptionalFunction('audio')
        const video = getOptionalFunction('video')

        const state = new Map()

        let ticksPerSecond = null
        let audioSamples = null
        let maximumVideoRows = null
        let safeAreaRows = null
        let safeAreaColumns = null
        let videoColors = null
        let pointerState = null
        let pointerRow = null
        let pointerColumn = null
        let persist = null
        let tickProgress = null
        let videoRows = null
        let videoColumns = null
        let listenerNormal = null
        let controllerStates = null
        let controllerYAxes = null
        let controllerXAxes = null
        let error = null

        for (let i = 0; i < stateBuffers; i++) {
          const identifier = stateBufferIdentifiers[i]

          if (state.has(identifier)) {
            throw new Error(`Buffer identifier "${identifier}" appears more than once.`)
          } else {
            const size = stateBufferSizes[i]
            const location = stateBufferLocations[i]

            if (size === 0) {
              throw new Error(`Buffer "${identifier}" has a size of 0.`)
            } else if (location + size > memory.buffer.byteLength) {
              throw new Error(`Buffer "${identifier}" overlaps the end of memory.`)
            } else if (identifier >= 0 && identifier <= 1073741823) {
              state.set(identifier, new Uint8Array(memory.buffer, location, size))
            } else if (identifier >= -1073741824 && identifier <= -1) {
              throw new Error(`Buffer "${identifier}" is required by the WASM module but is not supported by this hosting runtime.`)
            } else {
              switch (identifier) {
                case 1073741824:
                  if (size === 4) {
                    ticksPerSecond = new Int32Array(memory.buffer, location, 1)[0]

                    if (ticksPerSecond < 1) {
                      throw new Error(`Ticks per second incorrect; expected at least 1, actual ${ticksPerSecond}.`)
                    }
                  } else {
                    throw new Error(`Ticks per second size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741825:
                  if (size % 4 === 0) {
                    audioSamples = new Float32Array(memory.buffer, location, size / 4)
                  } else {
                    throw new Error(`Audio samples size incorrect; expected multiple of 4, actual ${size}.`)
                  }
                  break

                case 1073741826:
                  if (size === 4) {
                    maximumVideoRows = new Int32Array(memory.buffer, location, 1)[0]

                    if (maximumVideoRows < 1) {
                      throw new Error(`Maximum video rows incorrect; expected at least 1, actual ${maximumVideoRows}.`)
                    }
                  } else {
                    throw new Error(`Maximum video rows size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741827:
                  if (size === 4) {
                    safeAreaRows = new Int32Array(memory.buffer, location, 1)[0]

                    if (safeAreaRows < 1) {
                      throw new Error(`Safe area rows incorrect; expected at least 1, actual ${safeAreaRows}.`)
                    }
                  } else {
                    throw new Error(`Safe area rows size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741828:
                  if (size === 4) {
                    safeAreaColumns = new Int32Array(memory.buffer, location, 1)[0]

                    if (safeAreaColumns < 1) {
                      throw new Error(`Safe area columns incorrect; expected at least 1, actual ${safeAreaRows}.`)
                    }
                  } else {
                    throw new Error(`Safe area columns size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741829:
                  if (size % 4) {
                    throw new Error(`Video colors size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    videoColors = new Uint8ClampedArray(memory.buffer, location, size)
                  }
                  break

                case 1073741830:
                  if (size === 4) {
                    pointerState = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Pointer state size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741831:
                  if (size === 4) {
                    pointerRow = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Pointer row size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741832:
                  if (size === 4) {
                    pointerColumn = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Pointer column size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741833:
                  if (size === 4) {
                    persist = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Persist size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741834:
                  if (size === 4) {
                    tickProgress = new Float32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Tick progress size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741835:
                  if (size === 4) {
                    videoRows = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Video rows size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741836:
                  if (size === 4) {
                    videoColumns = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Video columns size incorrect; expected 4, actual ${size}.`)
                  }
                  break

                case 1073741838:
                  if (size === 12) {
                    listenerNormal = new Float32Array(memory.buffer, location, 3)
                  } else {
                    throw new Error(`Listener normal size incorrect; expected 12, actual ${size}.`)
                  }
                  break

                case 1073741839:
                  if (size % 4) {
                    throw new Error(`Controller states size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    controllerStates = new Int32Array(memory.buffer, location, size / 4)
                  }
                  break

                case 1073741840:
                  if (size % 4) {
                    throw new Error(`Controller Y axes size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    controllerYAxes = new Float32Array(memory.buffer, location, size / 4)
                  }
                  break

                case 1073741841:
                  if (size % 4) {
                    throw new Error(`Controller X axes size incorrect; expected multiple of 4, actual ${size}.`)
                  } else {
                    controllerXAxes = new Float32Array(memory.buffer, location, size / 4)
                  }
                  break

                case 1073741842:
                  if (size === 4) {
                    error = new Int32Array(memory.buffer, location, 1)
                  } else {
                    throw new Error(`Error size incorrect; expected 4, actual ${size}.`)
                  }
                  break
              }
            }
          }
        }

        if (videoColors !== null && maximumVideoRows === null) {
          videoColors = null
          console.warn('Unable to use video colors without maximum video rows.')
        }

        if (maximumVideoRows !== null && videoColors === null) {
          maximumVideoRows = null
          console.warn('Unable to use maximum video rows without a video colors.')
        }

        if (videoColors !== null && videoColors.length % maximumVideoRows) {
          throw new Error('Length of video colors not evenly divisible by the maximum number of video rows.')
        }

        const maximumVideoColumns = videoColors.length / maximumVideoRows

        if (safeAreaRows !== null && videoColors === null) {
          safeAreaRows = null
          console.warn('Unable to use safe area rows without video colors.')
        }

        if (safeAreaRows === null) {
          safeAreaRows = maximumVideoRows
        } else if (safeAreaRows > maximumVideoRows) {
          throw new Error('Safe area rows greater than video rows.')
        }

        if (safeAreaColumns !== null && videoColors === null) {
          safeAreaColumns = null
          console.warn('Unable to use safe area columns without video colors.')
        }

        if (safeAreaColumns === null) {
          safeAreaColumns = maximumVideoColumns
        } else if (safeAreaColumns > maximumVideoColumns) {
          throw new Error('Safe area columns greater than video columns.')
        }

        if (tickProgress !== null && ticksPerSecond === null) {
          tickProgress = null
          console.warn('Unable to use tick progress without ticks per second.')
        }

        if (audioSamples !== null && ticksPerSecond === null) {
          audioSamples = null
          console.warn('Unable to use audio samples without ticks per second.')
        }

        if (videoRows !== null && videoColors === null) {
          videoRows = null
          console.warn('Unable to use video rows without video colors.')
        }

        if (videoColumns !== null && videoColors === null) {
          videoColumns = null
          console.warn('Unable to use video columns without video colors.')
        }

        if (tick !== null && ticksPerSecond === null) {
          tick = null
          console.warn('Unable to use tick without ticks per second.')
        }

        if (tickProgress !== null && tick === null) {
          tickProgress = null
          console.warn('Unable to use tick progress without tick.')
        }

        if (tickProgress !== null && video === null) {
          tickProgress = null
          console.warn('Unable to use tick progress without video.')
        }

        if (audioSamples !== null && audio === null) {
          audioSamples = null
          console.warn('Unable to use audio samples without audio.')
        }

        if (audio !== null && audioSamples === null) {
          audio = null
          console.warn('Unable to use audio without audio samples.')
        }

        if (pointerRow !== null && pointerState === null) {
          pointerRow = null
          console.warn('Unable to use pointer row without pointer state.')
        }

        if (pointerRow !== null && videoColors === null) {
          pointerRow = null
          console.warn('Unable to use pointer row without video colors.')
        }

        if (pointerColumn !== null && pointerState === null) {
          pointerColumn = null
          console.warn('Unable to use pointer column without pointer state.')
        }

        if (pointerColumn !== null && videoColors === null) {
          pointerColumn = null
          console.warn('Unable to use pointer column without video colors.')
        }

        if (listenerNormal !== null && audioSamples === null) {
          listenerNormal = null
          console.warn('Unable to use listener normal without audio samples.')
        }

        if (controllerYAxes !== null && controllerStates === null) {
          controllerYAxes = null
          console.warn('Unable to use controller Y axes without controller states.')
        }

        if (controllerYAxes !== null && controllerYAxes.length !== controllerStates.length) {
          throw new Error(`Inconsistent number of controllers between states (${controllerStates.length}) and Y axes (${controllerYAxes.length}).`)
        }

        if (controllerXAxes !== null && controllerStates === null) {
          controllerXAxes = null
          console.warn('Unable to use controller X axes without controller states.')
        }

        if (controllerXAxes !== null && controllerXAxes.length !== controllerStates.length) {
          throw new Error(`Inconsistent number of controllers between states (${controllerStates.length}) and X axes (${controllerXAxes.length}).`)
        }
      } catch (reason) {
        console.error(reason)
        setMessage('Failed to load the game.  Please ensure that you have a stable internet connection and reload the page.  Report this problem alongside the name and version of your browser, operating system and device should it persist.')
      }
    }

    if ('serviceWorker' in navigator) {
      setMessage('Registering service worker...')

      navigator.serviceWorker
        .register('INSERT-SERVICE-WORKER-JS-PATH-HERE')
        .then(() => {
          loadGame()
        })
        .catch(reason => {
          console.error(reason)
          setMessage('Failed to configure a service worker.  Please reload the page.  Report this problem alongside the name and version of your browser, operating system and device should it persist.')
        })
    } else {
      loadGame()
    }
  </script>
</body>

</html>
